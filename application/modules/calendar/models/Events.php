<?php

/**
 * Calendar_Model_Events
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Calendar_Model_Events extends Calendar_Model_Base_Events
{
    /**
     * Date Format for events
     * @var string
     */
    private $date_format       =    'Y-m-d H:i:s';


    /**
     * Get a list of events for a specific group.
     *
     * @param Default_Model_Group $group
     * @param int $domain_id
     * @param int $start
     * @param int $end
     * @return array | NULL
     */
    public static function getEvents(Default_Model_Group $group, $domain_id, $start = NULL, $end = NULL)
    {
        if (NULL === $domain_id) {
            return;
        }

        if (NULL === $start) {
           $start = mktime(0, 0, 0, date('n'), 0, date('Y'));
        }

        if (NULL === $end) {
            $end = strtotime("+1 month", $start);
        }


        $dates = Doctrine_Query::create()
                 ->from('Calendar_Model_Events')
                 ->where('domain_id = ?', $domain_id)
                 ->andWhere('UNIX_TIMESTAMP(start) > ?', $start)
                 ->andWhere('UNIX_TIMESTAMP(start) < ?', $end)
                 ->andWhere('group_id = ?', $group->id)
                 //->useResultCache(true, 3600, 'events')
                 ->fetchArray();


        foreach ($dates as $key => $date) {
            $dates[$key]['start']       = strtotime($date['start']);
            $dates[$key]['end']         = strtotime($date['end']);
            $dates[$key]['allDay']      = $date['allday'];
            //$dates[$key]['url']         = "/calendar/event/detail/id/" . $date['id'];
            $dates[$key]['className']   = $group->style_id;
        }

        return $dates;
    }


    /**
     * Get a specific event based on it's event id
     *
     * @param int $event_id
     * @return Calendar_Model_Events | NULL
     */
    public static function getEvent($event_id = NULL)
    {
        if (NULL === $event_id) {
            return;
        }

        $event = Doctrine_Core::getTable('Calendar_Model_Events')->find($event_id);

        if (!$event instanceof Calendar_Model_Events) {
            return;
        }
        

        return $event;
    }

    /**
     * Add an event to the calendar
     *
     * @param array $data  'from', 'to', 'from_time', to_time
     */
    public function addEvent($data = NULL)
    {
        $identity = Zend_Auth::getInstance()->getIdentity();
        $this->domain_id = $identity['domain_id'];

        $this->synchronizeWithArray($data);
        
        if (isset($data['from']) && isset($data['from_time'])) {
            $from = new DateTime($data['from'] . " " . $data['from_time']);
            $this->start = $from->format($this->date_format);
        }

        // If the To is set, then try to create it, but also need to test that
        // It's in the future, else just set it an hour ahead.
        if (isset($data['to']) && isset($data['to_time'])) {
            $to = $data['to'] . " " . $data['to_time'];

            $this->end = $this->_checkStartEndDates($this->start, $to);
            
        }


        $this->save();


    }

    /**
     * Upadate an event
     *
     * @param array $data 'from', 'to', 'from_time', to_time
     */
    public function updateEvent($data = NULL)
    {
        if (NULL === $data) {
            throw new Exception("Data is null");
        }
        if (isset($data['from']) && isset($data['from_time'])) {
            $from = new DateTime($data['from'] . " " . $data['from_time']);
            $data['start'] = $from->format($this->date_format);
        }

        // If the To is set, then try to create it, but also need to test that
        // It's in the future, else just set it an hour ahead.
        if (isset($data['to']) && isset($data['to_time'])) {
            $to = $data['to'] . " " . $data['to_time'];

            $data['end'] = $this->_checkStartEndDates($data['start'], $to);

        }

        $this->synchronizeWithArray($data);
        $this->save();
    }

    /**
     * Get future events for a specific domain
     *
     * @param int $domain_id
     * @param int $days
     * @return array | NULL
     */
    public static function getUpcomingEvents($domain_id = NULL, $days = 31)
    {
        $now = time();
        $cut_off = strtotime("+" . $days . " days", $now);

        $events = Doctrine_Query::create()
                    ->from('Calendar_Model_Events e')
                    ->leftJoin('e.Group as g')                    
                    ->andWhere('e.start >= now()')
                    ->andWhere('UNIX_TIMESTAMP(e.end) <= ?', $cut_off)
                    //->useResultCache(true, 3600, 'upcoming_events')
                    ->orderBy('e.start');

        if (NULL !== $domain_id) {
            $events->andWhere('e.domain_id = ?', $domain_id);
        }

        return $events->fetchArray();
    }

    /**
     * Get an array of events for multiple groups
     *
     * @param int $ids
     * @param int $start
     * @param int $end
     * @return array
     */
    public static function getIcalEvents($ids = NULL, $start = NULL, $end = NULL)
    {
        if (NULL === $ids || NULL === $start || NULL === $end) {
            return;
        }
        
        $domain = Zend_Registry::get('domain');

        $data = array();
        foreach (Default_Model_Group::getGroupCollection($ids) as $group) {
            $events = array();
            $events = Calendar_Model_Events::getEvents($group, $domain['id'], $start, $end);
            foreach ($events as $event) {
                $data[] = $event;
            }

        }
        return $data;
    }

    /**
     * Check the start and end dates to make sure they are sane
     *
     * @param string $start
     * @param string $end
     * @return int
     */
    private function _checkStartEndDates($start, $end)
    {
        $unix_end       = strtotime($end);
        $unix_start     = strtotime($start);

        Zend_Registry::get('log')->debug("start: " . $unix_start . " ---  End: " . $unix_end);


        if ($unix_start >= $unix_end) {
            // Automatically add one hour to the time.
            return date($this->date_format, strtotime('+1 hour', $unix_start));
        }

        return date($this->date_format, $unix_end);


    }

    /**
     * Authorization function to make sure that a user has permissions to
     * perform the action they are requesting.
     *
     * @param string $action
     * @return bool
     */
    public function isAllowed($action)
    {
        $identity = Zend_Auth::getInstance()->getIdentity();

        switch ($action) {
            case 'delete':
                // Domain Id == event.domain_id
                if ($identity['domain_id'] == $this->domain_id) {
                    return TRUE;
                }
                break;

            case 'edit':
                if ($identity['domain_id'] == $this->domain_id) {
                    return TRUE;
                }
                break;

            default:
                return FALSE;
                break;
        }

        return FALSE;
    }

}